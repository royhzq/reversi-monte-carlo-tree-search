<!DOCTYPE html>
<html>
<head>
	<title>Reversi</title>
</head>
<body>

<div id="canvas">
	<svg id="board" width="800" height="800" 
		data-turn="1" 
		data-filled="[]" 
		data-neighbours="[]" 
		data-validspace="[]" 
		data-blackscore="" 
		data-whitescore=""
		>	
	</svg>
</div>
<div style="text-align: center; width:800px" id="Scoreboard">
	<span style="font-size:3rem">&nbsp;&#11044;&nbsp;</span><span style="font-size:2.5rem;" id="blackscore">2</span>
	&nbsp;&nbsp;
	<span style="font-size:3rem; color:grey">&nbsp;&#9711;&nbsp;</span><span style="font-size:2.5rem;" id="whitescore">2</span>
</div>
<br>
<div style="text-align: center; width:800px; font-size: 3rem">
	<span id="message">Thinking...</span>
</div>


<script type="text/javascript">

	function updateMessage(text) {
		// Update message notification for user.
		msg = document.getElementById("message");
		msg.innerHTML = text;
	}

	function inArray(target, array) {
		//  Check if target element is contained in array
		for(var i = 0; i < array.length; i++) {
			if(array[i] === target) {
	     	 	return true
			}
		}
		return false
	}

	function newBoard(dim) {
		// Return nxn array of arrays

		board =[]
		for (i=0; i <dim; i++) {
			board.push(Array(dim))
		}
		// Setup starting pieces
		var k = dim/2 -1
		board[k][k] = -1
		board[k][k+1] = 1
		board[k+1][k] = 1
		board[k+1][k+1] = -1

		return board
	}

	function drawGrid() {
		svg = document.getElementById("board")
		sqLength = width/dim
		gridBorder = ('<rect class="gridBorder" '
			+ 'x=0 ' 
			+ 'y=0 '
			+ 'width=' + width + ' '
			+ 'height=' + width + ' '
			+ 'style="fill:none; stroke-width:1 ; stroke:rgb(0,0,0)" />'
		)
		svg.innerHTML += gridBorder
		for (i=0; i < dim; i++) {
			for (j=0; j < dim; j++) {
				boardSquare = ('<rect '
						+ 'class="boardSquare"' 
						+ 'x=' + j*sqLength + ' '
						+ 'y=' + i*sqLength + ' '
						+ 'data-i=' + i + ' '
						+ 'data-j=' + j + ' '
						+ 'width=' + sqLength + ' '
						+ 'height=' + sqLength + ' '
						+ 'style="fill:transparent; stroke-width:0.5; stroke:rgb(0,0,0)" />'
				)
				svg.innerHTML += boardSquare

				// Render empty circles 
				emptyPiece = ('<circle ' 
					+ 'class="boardPiece" '
					+ 'id="piece-' + i + j +'" ' 
					+ 'data-value="0"'
					+ 'data-i=' + i + ' '
					+ 'data-j=' + j + ' '
					+ 'cx='+ (j*sqLength + sqLength/2) +' ' 
					+ 'cy=' + (i*sqLength + sqLength/2) +' '
					+ 'r=' + (0.9*sqLength/2) +' ' 
					+ 'fill=transparent '
					+ '/>'
				)
				svg.innerHTML += emptyPiece
			}
		}
	}

	function boardFreeze() {
		// Disallows click events on board
		document.getElementById("board").style.pointerEvents = "none";
		console.log("Board frozen..")
	}
	function boardThaw() {
		// Allows click events on board
		document.getElementById("board").style.pointerEvents = "";
		console.log("Board unfrozen..")
	}

	function getPiece(i,j) {
		// Get circle (piece) element given coordinates
		piece = document.getElementById("piece-"+i.toString()+j.toString())
		return piece
	}

	function getNeighbour(i, j) {
		// Given a coordinate, get positions of all immediate neighbouring empty spaces
		svg = document.getElementById("board")
		directions = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]] //N-NE-E-SE-S-SW-W-NW
		neighbours = []
		for (d = 0; d < directions.length ; d++) {
			i_new = parseInt(i) + directions[d][0]
			j_new = parseInt(j) + directions[d][1]
			if (i_new > dim-1 || j_new > dim -1 || i_new < 0 || j_new < 0) {
				continue;
			} else {
				if (getPiece(i_new, j_new).dataset.value == "0") {
					neighbours.push(i_new.toString() + j_new.toString())
				}							
			}
		}
		return neighbours
	}

	function initNeighbours() {
		// Initialize array of all empty spaces that are immediate neighbours of filled pieces on board
		svg = document.getElementById("board")
		turn = parseInt(svg.dataset.turn)
		filled = svg.dataset.filled.split(",")
		allNeighbours = []
		
		for (k = 0; k < filled.length; k++) {
			i_filled = parseInt(filled[k].split("")[0])
			j_filled = parseInt(filled[k].split("")[1])
			if (parseInt(getPiece(i_filled, j_filled).dataset.value) === -turn) {

				neighbours = getNeighbour(i_filled, j_filled)
				for (n = 0; n < neighbours.length; n++) {
					if (!inArray(neighbours[n], allNeighbours)) {
						allNeighbours.push(neighbours[n])
					}
				}	 
			}
		}
		svg.dataset.neighbours = allNeighbours
	}
	
			//Update neighbours
			//First create empty set of neighbours and loop through..

	function checkValidDir(i, j, iDir, jDir) {
		
		// Check, in the direction (iDir, jDir), whether pieces will flip
		// Direction is defined by (iDir, jDir), for example,
		// if (iDir=1, jDir=1), we are checking the N-E direction of a given space (Tuple)
		// if (iDir=0, jDir=-1), we are checking the West direction of a given space (Tuple)

		//First Check if space is empty. Space has to be empty (0) to be valid
		// console.log('checkValidDir: ', i, j, iDir, jDir)
		var valid = false;
		svg = document.getElementById('board')
		piece = getPiece(i, j)

		if (!parseInt(piece.dataset.value)===0) {
			return false
		} 
		firstShift = true //shift to first neighbour in the iDir jDir direction
		while (true) {
			i = parseInt(i) + iDir
			j = parseInt(j) + jDir 
			currPiece = getPiece(i, j)
			// console.log("CurrPiece: ", i, j, currPiece)
			if (i > dim-1 || j > dim-1 || i < 0 || j < 0) {
				// coordinates our of range
				// console.log("Case 1: out of range", i, j, iDir, jDir)
				break;
			} else if (currPiece.dataset.value === "0") {
				// if space is empty
				// console.log("Case 2: space is empty", i, j, iDir, jDir)
				break;
			} else if (currPiece.dataset.value === svg.dataset.turn && firstShift === true ) {
				//If the current space is same colour - Invalid
				//This only applies when current space is the first neighbour of the original starting space
				// console.log("Case 3: space is same colour", i, j, iDir, jDir)
				break ;	
			} else if (currPiece.dataset.value === svg.dataset.turn && firstShift === false) {
				//If the current space is same colour, but shifted before,
				//means that previous space is different colour, end the check and this
				//is where all pieces in this direction up to this piece is flipped
				//this will then be valid
				// console.log("Case 4: Valid Direction", i, j, iDir, jDir)
				valid = true;
				break ;
			} else if (parseInt(currPiece.dataset.value) === -parseInt(svg.dataset.turn)) {
				firstShift = false;
				// console.log("Case 5: Moving on...", i, j, iDir, jDir)
				continue;
			}

		}

		return valid
	}

	function checkValid(i, j) {
		directions = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]] 
		for (d=0; d < directions.length; d++) {
			if (checkValidDir(i,j, directions[d][0], directions[d][1])) {
				return true;
			}
		}
		return false;
	}

	function getAllValid() {
		svg = document.getElementById("board")
		allNeighbours = svg.dataset.neighbours.split(",")
		validspace = []
		// console.log("allNeighbours in getAllValid(): ", allNeighbours, svg.dataset.neighbours)
		if (allNeighbours.length >= 1 && allNeighbours[0]!= "" ) {
			for (n=0; n < allNeighbours.length; n++) {
				if(checkValid(parseInt(allNeighbours[n][0]), parseInt(allNeighbours[n][1]))) {
					validspace.push(allNeighbours[n])
				}
			}
		}
		svg.dataset.validspace = validspace
	}

	function renderBoard(board, turn) {

		//Set which side's turn "1"- black, "-1" white
		svg = document.getElementById("board")
		svg.dataset.turn = turn
		blackscore = 0
		whitescore = 0
		filled = []

		for (i=0; i < board.length; i++) {
			for (j=0; j < board.length; j++) {
				pieceVal = board[i][j] 
				piece = getPiece(i,j)

				if (pieceVal == 1) {
					piece.style.fill = "black"
					piece.style.stroke ="black"
					piece.dataset.value = "1"
					filled.push(i.toString() + j.toString())
					blackscore += 1
				}  
				if (pieceVal == -1) {
					piece.style.fill = "white"
					piece.style.stroke ="black"
					piece.dataset.value = "-1"
					filled.push(i.toString() + j.toString())
					whitescore += 1
				}	
			}
		}

		svg.dataset.blackscore = blackscore 
		svg.dataset.whitescore = whitescore
		svg.dataset.filled = filled

		initNeighbours()
		getAllValid()
	}

	function Move(i,j, agent) {

		agent = (typeof agent !== 'undefined') ? agent: false; //true if move was made by agent

		svg = document.getElementById("board");
		turn = svg.dataset.turn;
		filled = svg.dataset.filled.split(",");
		validspace = svg.dataset.validspace.split(",");
		directions = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]] ;
		flippedCount = 0;
		piece = getPiece(i,j);
		console.log(i,j, " ->MOVE");
		
		if (!inArray(i.toString()+j.toString(), validspace)) {
			console.log("This is an invalid move")
		} else {
			boardFreeze();
			if (turn == "1") {
				piece.style.fill = "black"
				piece.style.stroke ="black"
				piece.dataset.value = "1"
			}
			if (turn == "-1") {
				piece.style.fill = "white"
				piece.style.stroke ="black"
				piece.dataset.value = "-1"
			}

			// Update filled pieces array
			filled.push(i.toString() + j.toString())
			svg.dataset.filled = filled
			// console.log("New Filled: ", svg.dataset.filled, filled)


			for (d=0; d < directions.length; d++) {
				// Validity has been checked 
				// Flip all opposing pieces in the direction until same colour is met. 
				var temp_i = parseInt(i)
				var temp_j = parseInt(j)
				if (checkValidDir(i,j,directions[d][0],directions[d][1])){

					// console.log("Direction: ", directions[d][0],directions[d][1], " is true for move", i,j)
					while (true) {
						temp_i += directions[d][0]
						temp_j += directions[d][1]
						nextPiece = getPiece(temp_i,temp_j)	
						// console.log("nextPiece: ", temp_i, temp_j, nextPiece)
						if (parseInt(nextPiece.dataset.value) === parseInt(turn)) {
							break;
						} else {
							//Flip the next piece and move
							piece.dataset.value = turn 
							nextPiece.dataset.value = turn
							if (turn === "1") {
								piece.style.fill = "black"
								nextPiece.style.fill = "black"
								nextPiece.style.stroke ="black"
								// console.log("To Black: ", piece)
							}
							if (turn === "-1") {
								piece.style.fill = "white"
								nextPiece.style.fill = "white"
								nextPiece.style.stroke ="black"
								// console.log("To Whhite: ", piece)

							}
							flippedCount += 1
						}
					}
				} else { 
					// console.log("Direction: ", directions[d][0],directions[d][1], " is false for move", i,j)
				}
			}

			//Update score
			if (turn === "1") {
				// Total score increase is = all flipped pieces + 1 new piece placed
				svg.dataset.blackscore = parseInt(svg.dataset.blackscore) + flippedCount + 1 
				svg.dataset.whitescore = parseInt(svg.dataset.whitescore) - flippedCount  
			} 	
			if (turn === "-1") {
				// Total score increase is = all flipped pieces + 1 new piece placed
				svg.dataset.whitescore = parseInt(svg.dataset.whitescore) + flippedCount + 1 
				svg.dataset.blackscore = parseInt(svg.dataset.blackscore) - flippedCount  
			}

			document.getElementById("blackscore").innerHTML = svg.dataset.blackscore;
			document.getElementById("whitescore").innerHTML = svg.dataset.whitescore;

			// Change to next turn
			turn = -parseInt(turn)
			svg.dataset.turn = turn
			// console.log("Change turn to: ", svg.dataset.turn)
			
			//Update neighbours
			//First create empty set of neighbours and loop through..
			initNeighbours()
			// console.log("New All Neighbours: ", svg.dataset.neighbours)
			//Update validSpace
			getAllValid()
			// console.log("NEW VALID SPACE: ",svg.dataset.validspace)

			//Scenario where there are no more valid moves
			validspace = svg.dataset.validspace.split(",")
			// console.log(validspace, validspace.length)

			if (validspace.length === 1 && validspace[0] == "") {
				// Skip a turn
				// console.log("SKIP A TURN")
				turn = -parseInt(turn)
				svg.dataset.turn = turn
				initNeighbours()
				// console.log("New All Neighbours: ", svg.dataset.neighbours)
				getAllValid()
				// console.log("NEW VALID SPACE: ",svg.dataset.validspace)	
				validspace = svg.dataset.validspace.split(",")

				// Both players have no more moves
				if (validspace.length === 1 && validspace[0] == "") {
					blackscoreFinal = parseInt(svg.dataset.blackscore)
					whitescoreFinal = parseInt(svg.dataset.whitescore)
					if (blackscoreFinal > whitescoreFinal) {
						alert("Black wins: ", blackscoreFinal, " : ", whitescoreFinal)
					} else if (blackscoreFinal < whitescoreFinal) {
						alert("White wins: ", blackscoreFinal, " : ", whitescoreFinal)
					} else {
						alert(" Draw: ", blackscoreFinal, " : ", whitescoreFinal)
					}
				} else {
					if (agent) {
						// If the move was made by the agent, the agent gets to moves again
						agentMove(turn)
					} else {
						// If the move was made by user, user gets to move again
						boardThaw() //Unfreeze board for user's turn again
					}
				}

			} else {
				if (!agent) {
					// If the move was not made by the agent,
					// It is agent's turn to move
					agentMove(turn)
				}
			}
		}
	}

	function getColourArrays() {

		// Function to get array of black positions and array of white positions
		// For consumption of agentMove endpoint
		
		filled = document.getElementById("board").dataset.filled.split(",")
		blackArray = []
		whiteArray = []
		for (k=0; k < filled.length; k++) {
			piece  = document.getElementById("piece-"+filled[k])
			if (piece.dataset.value == 1) {
				blackArray.push([parseInt(piece.dataset.i), parseInt(piece.dataset.j)])
			}
			if (piece.dataset.value == -1) {
				whiteArray.push([parseInt(piece.dataset.i), parseInt(piece.dataset.j)])
			}
		}
		return {
			"blackArray":blackArray,
			"whiteArray":whiteArray
		}
	}

	function agentMove(turn) {
  		
		// AJAX POST request to obtain agent's Move 
		// turn: Agent plays as black (1) or white (-1) in the next move
		updateMessage("Thinking...")
		var colourArrays = getColourArrays();
  		var xhttp = new XMLHttpRequest()
  		xhttp.onreadystatechange = function () {
    		if (this.readyState === 4 && this.status === 200) {
    			var json_response = JSON.parse(this.response)
    			Move(json_response['move'][0], json_response['move'][1], agent=true)
    			// console.log(json_response)
    			boardThaw(); // Always unfreeze board for user to play next
    			updateMessage("Your Turn.")
    			return json_response
    		}
  		}
		xhttp.open('POST', '/search_move', true)
		xhttp.setRequestHeader('Content-Type', 'application/json')
		xhttp.send(
		JSON.stringify({
			"blackFilled":colourArrays["blackArray"],    // Positions on board filled with black pieces
			"whiteFilled":colourArrays["whiteArray"],    // Positions on board filled with white piece
			"turn":turn,                 // Agent's turn to play as (1 black, -1 white)
			})	
		)
	}


	width =800 
	dim = 8
	drawGrid()
	boardPieces = document.getElementsByClassName("boardPiece")
	boardSquares = document.getElementsByClassName("boardSquare")

	for (m=0; m < boardSquares.length; m++ ){

		boardSquares[m].addEventListener("click", function() {
			Move(this.dataset.i, this.dataset.j);
		})
	}
	for (m=0; m < boardPieces.length; m++ ){

		boardPieces[m].addEventListener("click", function() {
			Move(this.dataset.i, this.dataset.j);
		})
	}
	// document.getElementsByTagName('')ElementById("board").innerHTML='<circle cx="100" cy="200" r="40" stroke="black" stroke-width="4" fill="yellow" />'
	b = newBoard(dim);
	renderBoard(b, "1");
	boardFreeze();
	agentMove(1);
	initNeighbours();

</script>
</body>
</html>